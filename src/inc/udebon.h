/*********************************************************************
**
**		NAME			:	udebon.h
**    CONTAINS    :  uu_denter(xTRC,(us,"format",v1,v2,..));
**							uu_denter2(xTRC,(us,"format",v1,v2,..));
**							uu_dprint(xTRC,(us,"format",v1,v2,..));
**							//uu_dexit;;
**
**			Debugging package. Include exp/src/debug.h. Library exp/lib/utllib.a.
**       Denter must be the first executable statement of a function. It
**					does an sprintf using the "format" and variables v1,v2.. and 
**					stores the resulting string on a stack. 
**			Denter2 does the same thing, but does not have to be the first 
**					executable statement in a function. If you use denter2 and not
**					denter in a function, you must declare us to be a character
**					array long enough to hold the string generated by 
**					sprintf("format",v1,v2..). 
**			Dprint is equivalent of denter, but does not require a following dexit.
**					There is no stack push.
**			Dexit should be called just before the function returns. There must
**					be a call to dexit for each call to denter or denter2.
**			First call to Denter or Denter2 sets up to catch keyboard interrupts 
**			(ctrl c). On keyboard interrupt, the current procedure stack 
**			is printed and the user is prompted for what he would like to do.
**			Choices are: resume, turn on/off tracing of any sub-system, exit.
**			
**			Debugging traces are printed using the UNICAD I/O re-direction system,
**			logical device EO (error out). Currently this is set up to go to a disk
**			file whose name is given by the UNIX shell variable "trc". 
**			If "trc" does not exist, a file named "trc" will be used. To create 
**			shell variable "trc" type: 
**					trc=filename
**					export trc
**
**    COPYRIGHT 1984 (c) UNICAD Inc.  All Rights Reserved.
**
**    MODULE NAME AND RELEASE LEVEL 
**       udebon.h , 25.1
**    DATE AND TIME OF LAST MODIFICATION
**       04/29/15 , 15:07:03
**    PARAMETERS   
**
**       INPUT  : us--name of a char string. Must be us, no other name.
**						xTRC -- x is one of: G,D,M,X,R,S,K,I,N. Identifies your
**								subsystem as follows:
**								G=GKS, D=DAS, M=Modelling, X=Disk I/O,
**								R=RDBMS, S=SAL, K=KOS, I=User Interface, N=Math.
**						format--a string acceptable as a format to sprintf.
**						v1,v2... -- variable list acceptable to sprintf.
**
**    RETURNS      : none
**    SIDE EFFECTS : First call to Denter or Denter2 sets up to catch
**							keyboard interrupts. 
**    WARNINGS     : Denter/Dexit calls must pair up. If the string generated
**							by sprintf(us,"format",v1,v2..) is greater than 80
**							characters, do not use denter, but use denter2
*********************************************************************/

//#define  UDEBONH
#ifndef UDEBONH
#include "umasks.h"

//#undef UU_DEBUGMAIN
//#ifdef UU_DEBUGMAIN
//#undef UU_DEBUGMAIN
//#endif
/* Define the required global variables */
#ifdef UU_DEBUGMAIN
	int 		UU_stklen=0;						/* Current stack length */
	char 		ustk[UU_STKDEPTH][150];			/* Stack of strings */
	char  	*(addstk[UU_STKDEPTH]);			/* Stack of string addresses */
	int 		UU_debmask;							/* Debug mask */
#else
	extern int  UU_stklen;						/* Current stack length */
	extern char ustk[UU_STKDEPTH][150];		/* Stack of strings */
	extern char *(addstk[UU_STKDEPTH]);		/* Stack of string addresses */
	extern int  UU_debmask;						/* Debug mask */
#endif

#define UU_DEBUG 0

#define uu_denter(mask,arg) char us[150];\
	if (UU_debmask & mask) { sprintf arg ; uu_enter(us);}\
	else { \
		strcpy arg; \
		addstk[UU_stklen]=us;  \
		strcpy(&ustk[UU_stklen++][0],us); }

#define uu_denter2(mask,arg)\
	if (UU_debmask & mask) { sprintf arg ; uu_enter(us);}\
	else { \
		strcpy arg ;  \
		addstk[UU_stklen]=us;  \
		strcpy(&ustk[UU_stklen++][0],us); }

#define uu_dprint(mask,arg)\
	{ if (UU_debmask & mask) { sprintf arg ; uu_trcprint(us);} }

#define uu_dexit if (UU_stklen>0) { \
						  UU_stklen--; \
						  if(addstk[UU_stklen] != us) uu_exit(us); \
					  } \
					  else uu_exit(us)

#define uu_dexit status(routine_name, status)\
	if (status != UU_SUCCESS) {\
		sprintf(us,"%s returns FAILURE",routine_name);\
		uu_trcprint(us);\
		}\
	if (UU_stklen>0) { \
		  UU_stklen--; \
		  if(addstk[UU_stklen] != us) uu_exit(us); \
		  } \
	else uu_exit(us)
#define UDEBONH
#endif

